06.02.2024
Parsing FEN strings determines ordering of piece lists in Position. Consequently it determines move generation order. 
So probably this will cause engine to play color-flipped position much weaker/ stronger.
Should either do some nice move ordering or at least shuffle generated moves at random?

08.02.2024
Thinking about attack LUT and promotions. At first I thought that I should consider promotions in attack LUT 
(e.g pawn should square on the other side  the board be flagged as 'attacked by pawn on promotion rank'). But then I realized
that the table is indexed by square difference, not by actual squares. So one entry in the table can originate from arbitrary rank-
not necessarily from the promoting rank.
Looks like promoting and then looking up is the way to go. Also.. pretty natural in typical movegen algorithm (generate pseudolegal and then filter out illegal)

15.02.2024
Done with perft test suite. Machess completes the suite in ~46.6 seconds; magog completes the same test in ~27.0 s! Great!

22.03.2024
Done with iterative perft. The implementation is on the "iterativePerft" branch. 
Perftsuite (recursive) done in ~27.4 s. Iterative version completed in ~27-29s. 
Disappointing result - was expecting some speedup after reading https://www.talkchess.com/forum3/viewtopic.php?t=53408

26.03.2024
Done with basic static position evaluation. Includes material and mobility. I've decided to copy-paste-modify original move generation code rather
than make the old one more general. This way I can skip the need for slice with moves completely. As a bonus I discovered that I can skip 
some superfluous legality tests:
-now I have one legality test for all 4 promotions
-no need to do legality test after castling
Another minor optimization: appending four promotions at once

28.03.2024
Movegen with checking for doublechecks: ~23,2s

05.04.2024
Movegen with specialized movegen in leaf nodes (doublechecks, captures, interpo)

23.04.2024
Couldn't get movegen any faster really. Version with pin checking is way slower. Would like to investigate later. All the intermediate work is left at 
specialized_movegen branch.

24.04.2024
Testing search and evaluate/score functions. Found an interesting bug while calculating mobility score. When calculating mobility of enemy pieces (the ones that are not moving).
The piece tries to take its own pawn because the enPassant square is set. So simply making a null-move does not guarrantee calculating correct mobility of enemy pieces. Luckily
this caused panic and rather than falfifying mobility score. So clean crash rather than elusive bug. Probably Machess engine has the same bug that went undetected!

09.05.2024
About iterative deepening under time control.
Just finished one of the first games against engine. I added a timeout condition in the search loop. This way engine does not spend too much time searching exhaustively at 
depth reached (which makes it loose on time).
However we cannot simply break out from the search loop in arbitrary moment because this will cause engine to miss obvious moves. Specifically we must not quit right after descending
on depth deeper. Here a relevant log from Arena with my comments added:

    2024-05-06 19:56:02,164-->1:position startpos moves e2e4 c7c5 g1f3 d8c7 f1c4 e7e6 b1c3 d7d6 d2d3 c7d8 c1e3 g7g6 d1d2 b8c6 e3g5  // black to move, black queen at d8 is hanging
    2024-05-06 19:56:02,164-->1:go wtime 239171 btime 236628 winc 0 binc 0
    2024-05-06 19:56:02,165<--1:info score 305 pv d8g5 depth 1
    2024-05-06 19:56:02,171<--1:info score -180 pv d8a5 c4e6 depth 2
    2024-05-06 19:56:02,332<--1:info score 65 pv d8a5 b2b4 c5b4 depth 3
    2024-05-06 19:56:08,700<--1:info score -190 pv f8e7 c4b5 e7g5 b5c6 depth 4                                                      // completed search at depth 4 - found reasonable continuation
    2024-05-06 19:56:10,052<--1:timeout!                                                                                            // timeout reached while searching at depth 5 - starting to return from recursive calls
    2024-05-06 19:56:10,052<--1:timeout!
    2024-05-06 19:56:10,053<--1:timeout!
    2024-05-06 19:56:10,053<--1:timeout!
    2024-05-06 19:56:10,053<--1:timeout!    
    2024-05-06 19:56:10,053<--1:info score -10 pv f8g7 c3b5 g7c3 d2c3 d8g5 depth 5                                                  // what is returned is a search partially completed searched at depth 5 - it didn't even see that queen is hanging, 
    2024-05-06 19:56:10,055<--1:info pv f8g7 c3b5 g7c3 d2c3 d8g5
    2024-05-06 19:56:10,055<--1:bestmove f8g7                                                                                       // engine hangs a queen

09.05.2024 - 2
Got it working but still got the following situation where it hangs the queen. But this blunder can be attributed to lack of quiescence search 
(obviously it thinks it captured a piece at the end of the line). Log below:

    position startpos moves e2e4 e7e6 f1c4 d8f6 b1c3 f6d4 g1f3 d4c4 d2d3
    go wtime 332611 btime 261957 winc 0 binc 0 
    info pv  b8a6 score 315
    info pv  b8c6 score 335
    info pv  c4c3 score 780
    info score 780 pv c4c3 depth 1
    info pv  c4c3 b2c3 score -320
    info pv  c4c5 c1g5 score 280
    info pv  c4b4 c1g5 score 305
    info score 305 pv c4b4 c1g5 depth 2
    info pv  c4b4 e1e2 b4c3 score 645
    info score 645 pv c4b4 e1e2 b4c3 depth 3
    info pv  c4b4 f3g5 b8c6 g5f7 score 230
    info score 230 pv c4b4 f3g5 b8c6 g5f7 depth 4
    info pv  c4b4 a2a3 b4c5 c3e2 c5f2 score 585                          // at depth 5 started of with line similar from depth 4
    info pv  f8d6 f3g5 c4b4 c1d2 b4c3 score 655                          // but falsely found "sth even better" - end of this sequence hangs a queen
    info score 655 pv f8d6 f3g5 c4b4 c1d2 b4c3 depth 5
    info pv f8d6 f3g5 c4b4 c1d2 b4c3 score 655
    bestmove f8d6

17.05.2024
Completed quiescence search. Dode a 10 round tournament against Machess (5 openings as both black and white). Results are kind of disappointing :).
It lost all 10 out of 10 rounds! :)
Looks like it is simply slower. In scandinavian defense machess took 6 seconds to find the e4e5. 
Magog took 6s for the same move.
Time to investigate - probably it is due to bad move ordering machess searches captures first 
(and also has separate piece list per piece type)
but it could also be a problem with small NPS.. (simply slow raw movegen and evaluation function)

22.05.2024
Yup the engine has 200k less nps than Machess (~500k vs ~300k). Did some profiling with go pprof and found out that 
isUnderCheckMethod appears quite high on the list.
To be more specific switch in that method is quite hot.

Here's a pprof list (note that it's not exactly from the commited version - this is a color-blind of the switch cases - see lines: 296, 297, 302.. anyway the results are on par)

    (pprof) list isUnderCheck
    Total: 28.55s
    ROUTINE ======================== macsmol/magog/engine.(*Position).isUnderCheck in C:\Users\Maciej\workspaces\go\magog\engine\position.go
        3.47s      3.73s (flat, cum) 13.06% of Total
        60ms       60ms    292:func (pos *Position) isUnderCheck(enemyPieces []square, enemyKing square, destSquare square) bool {
            .          .    293:   var moveIdx int16
        300ms      300ms    294:   for _, attackFrom := range enemyPieces {
        60ms      260ms    295:           moveIdx = moveIndex(attackFrom, destSquare)
        1.17s      1.17s    296:           switch pos.board[attackFrom]&ColorlessPiece {       
            .          .    297:           case Knight:
        170ms      170ms    298:                   if attackTable[moveIdx]&KnightAttacks == 0 {
            .          .    299:                           continue
            .          .    300:                   }
            .          .    301:                   return true

So I thought that maybe the switch in Golang is kindof slow (a premonition I have ever since I 
debugged a switch statement in Golang - for some reason you never jump directly to the desired case, you have to step over few times. This never happened in Java).
Following that lead I've made a version that uses a LUT with isCheckedByXX function containing
functions for each piece. This worked much slower (~200k nps). 
Here's the relevant listing:

    (pprof) list Check
    Total: 36.26s
    ROUTINE ======================== macsmol/magog/engine.(*Position).isUnderCheck in C:\Users\Maciej\workspaces\go\magog\engine\position.go
        3.63s      7.63s (flat, cum) 21.04% of Total
        140ms      140ms    332:func (pos *Position) isUnderCheck(enemyPieces []square, enemyKing square, destSquare square) bool {
            .          .    333:   var moveIdx int16
        760ms      760ms    334:   for _, attackFrom := range enemyPieces {
        10ms      2.24s    335:           moveIdx = moveIndex(attackFrom, destSquare)
        480ms      480ms    336:           lutIdx := pos.board[attackFrom] & ColorlessPiece - 1
        2.18s      3.92s    337:           if checkFunctionsLUT[lutIdx](attackFrom, destSquare, moveIdx, &pos.board) {
            .          .    338:                   return true
            .          .    339:           }
            .          .    340:   }
            .          .    341:
            .       30ms    342:   moveIdx = moveIndex(enemyKing, destSquare)
        40ms       40ms    343:   kingAttack := attackTable[moveIdx]&KingAttacks != 0
        20ms       20ms    344:   return kingAttack
            .          .    345:}
            .          .    346:
            .          .    347:func checkedBySlidingPiece(slidingPieceSquare, destSquare square, moveIndex int16, board *[128]piece) bool {